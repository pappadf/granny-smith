# Macintosh Plus Keyboard Communication Protocol (Non-ADB, VIA shift-register interface)

This document is intended as a **single, implementation-focused reference** for
emulating the **Macintosh Plus / 128K / 512K / 512Ke family “non‑ADB” keyboard**
interface: the synchronous serial protocol used before Apple Desktop Bus (ADB)
appeared on the Macintosh SE and later systems.

It combines the **wire protocol and timings** with **Mac-side VIA (6522)
shift-register behavior** and the **classic Mac OS keyboard-driver
expectations**, so emulator authors can implement both the electrical/protocol
layer and the OS-visible results.

## Emulator API: ADB Virtual Key Codes

This emulator uses **ADB virtual key codes** (from *Inside Macintosh* Vol V) as
the standard API between platform frontends and the keyboard emulation core.
This design allows easy future support for ADB-based Macintosh models (SE, II,
etc.) while maintaining compatibility with the Mac Plus VIA-based protocol.

The `keyboard_update()` function accepts ADB virtual key codes and translates
them internally to Mac Plus raw transition bytes.

---

## 1. Hardware overview

### 1.1 Keyboard internals (high level)

- The keyboard is a **keyswitch matrix** scanned by an onboard microcontroller
  (commonly **Intel 8021** or compatible).
- The microcontroller detects **switch transitions** (press and release) and
  converts them into serialized **key-down / key-up transition bytes**.

> For emulation you generally do _not_ need to model the exact matrix; you need
> the same _observable_ behavior: transitions are reported one at a time in
> response to Mac polling, with the correct encoding and timing.

### 1.2 Physical connector and pinout

The Macintosh Plus keyboard port is a **4-wire RJ‑11 telephone-style connector**
(often physically an RJ‑11 jack). The keyboard cable carries power plus the two
protocol lines.

**RJ‑11 (4-pin) assignments:**

| Pin | Signal | Direction      | Description                                                   |
| --- | ------ | -------------- | ------------------------------------------------------------- |
| 1   | GND    | —              | Ground                                                        |
| 2   | CLOCK  | Keyboard → Mac | Keyboard-generated clock (input to VIA)                       |
| 3   | DATA   | Bidirectional  | Serial data line (driven by whichever side is sending)        |
| 4   | +5V    | Mac → Keyboard | +5V DC power (shared; commonly cited as up to ~200 mA budget) |

### 1.3 Signal lines (electrical behavior)

The protocol uses only two active signals:

| Signal    | Description                             | Direction      |
| --------- | --------------------------------------- | -------------- |
| **DATA**  | Bidirectional serial data               | Mac ↔ Keyboard |
| **CLOCK** | Synchronous clock generated by keyboard | Keyboard → Mac |

- **Idle state:** CLOCK is normally **high** when idle; DATA idles **high**.
- The **keyboard always generates the clock**, even when the Macintosh is the
  one sending the data byte.
- DATA is driven by whichever device is currently transmitting; the other side
  must release the line.

### 1.4 Macintosh-side interface hardware (VIA + synchronizer)

Inside the Macintosh Plus, the keyboard lines connect through **VIA1 (6522)**,
using the VIA’s **shift register (SR)** for serial transfer. Some board
revisions include a **PAL-based clock synchronizer** to ensure timing
compatibility between the external clock and the VIA sampling domain (see the
_Guide_’s keyboard interface figure).

---

## 2. VIA1 registers and how the Mac uses them

### 2.1 Relevant VIA1 registers

The keyboard interfaces through **VIA1** (base address pointer in low memory at
`$1D4`, often named `VIA`). The key registers for the keyboard are:

| VIA Register | Offset  | Purpose                                                                      |
| ------------ | ------- | ---------------------------------------------------------------------------- |
| `vSR`        | `$1400` | **Shift Register** (serial byte data)                                        |
| `vACR`       | `$1600` | **Auxiliary Control Register** (select SR mode, direction, clocking)         |
| `vPCR`       | `$1800` | **Peripheral Control Register** (handshake control; platform-specific usage) |
| `vIFR`       | `$1A00` | **Interrupt Flag Register**                                                  |
| `vIER`       | `$1C00` | **Interrupt Enable Register**                                                |

The VIA’s SR completion interrupt flag is **`ifSR` = bit 2** in `vIFR`.

### 2.2 SR direction and mode

The SR supports shift-in and shift-out; direction is controlled by the `SRdir`
bit in `vACR`:

- `SRdir = 0` → shift **in** (keyboard → Mac)
- `SRdir = 1` → shift **out** (Mac → keyboard)

The Mac flips SR direction at well-defined moments (after it has finished
shifting out a command byte, it switches to shift-in mode to receive the
keyboard’s reply).

### 2.3 Interrupt vector used by the ROM/OS

On classic Macs using this interface, the keyboard is serviced via the **VIA1
shift-register interrupt** (SR done).

A common convention in Apple source is:

```
jKbdAdbInt  equ  Via1DT+4*ifSR    ; Shift Register interrupt vector
```

Where `Via1DT` (aka `Lvl1DT`) is the VIA1 dispatch table and `ifSR` is the SR
interrupt index (2). This yields vector offset `$192 + 4*2 = $19A` on systems
that use that low-memory dispatch scheme.

---

## 3. Wire protocol fundamentals

### 3.1 Master/slave roles and initiation

This is a **master–slave** protocol:

- The **Macintosh is always the initiator**.
- The keyboard is passive until the Mac signals it should begin a transaction.

A typical transaction begins like this:

1. The Mac signals readiness/attention by pulling **DATA low**.
2. The keyboard detects DATA low and begins generating clock pulses.
3. The Mac transmits an **8-bit command byte** (clocked by the keyboard).
4. The command’s last bit leaves DATA low.
5. The Mac releases/sets **DATA high** to indicate it is ready to receive.
6. The keyboard transmits an **8-bit response byte** (again using
   keyboard-generated clock pulses).

### 3.2 Framing and bit order

- **Frame size:** 8 bits per byte.
- **Order:** **MSB first**.
- No extra start/stop bits; the clock pulses delimit the byte.

---

## 4. Timing specifications (critical for accurate emulation)

The keyboard generates 8 clock cycles per transferred byte. The keyboard uses
different nominal bit timing depending on direction.

### 4.1 Keyboard → Macintosh (response byte)

For keyboard-to-Mac response transfers:

| Parameter                      | Typical value            |
| ------------------------------ | ------------------------ |
| Clock cycles                   | 8 per byte               |
| Clock period                   | ~330 µs per cycle        |
| Clock low                      | ~160 µs                  |
| Clock high                     | ~170 µs                  |
| Data setup before falling edge | ~40 µs                   |
| VIA sampling edge              | **Rising edge** of CLOCK |

The keyboard drives each DATA bit ~40 µs before the falling edge and keeps it
valid across the cycle; the VIA shifts it in on the rising edge.

### 4.2 Macintosh → Keyboard (command byte)

For Mac-to-keyboard command transfers:

| Parameter             | Typical value                |
| --------------------- | ---------------------------- |
| Clock cycles          | 8 per byte                   |
| Clock period          | ~400 µs per cycle            |
| Clock low             | ~180 µs                      |
| Clock high            | ~220 µs                      |
| Mac updates DATA      | On **falling edge** of CLOCK |
| Keyboard samples DATA | ~80 µs after rising edge     |

Even though the Mac is sending, the **keyboard still produces the clock**.

---

## 5. Command set (Mac → keyboard)

The Macintosh sends one-byte commands. Common commands are:

| Command          | Value | Keyboard response                                                                   |
| ---------------- | ----- | ----------------------------------------------------------------------------------- |
| **Inquiry**      | `$10` | Transition code, or **Null** `$7B` after a ¼-second timeout with no changes         |
| **Instant**      | `$14` | Transition code if available, otherwise immediate **Null** `$7B` (no ¼-second wait) |
| **Model Number** | `$16` | Model byte (and keyboard resets itself)                                             |
| **Test**         | `$36` | **ACK** `$7D` (pass) or **NAK** `$77` (fail)                                        |

### 5.1 Inquiry (`$10`)

Normal polling command.

- If a key transition is pending, the keyboard returns one transition byte.
- If no transition occurs within ~¼ second, it returns **Null** `$7B`.

Classic Mac software typically issues Inquiry about every **¼ second** during
normal operation.

### 5.2 Instant (`$14`)

Like Inquiry, but without waiting up to ¼ second:

- Transition byte if one is pending.
- Otherwise immediate **Null** `$7B`.

### 5.3 Model Number (`$16`)

Initialization command. On receipt, the keyboard:

1. Resets itself
2. Returns a model/chain byte

**Response bit layout:**

| Bit | Meaning                                                        |
| --- | -------------------------------------------------------------- |
| 0   | Always `1`                                                     |
| 1–3 | Keyboard **model number** (1–8)                                |
| 4–6 | **Next device number** (1–8)                                   |
| 7   | `1` if **another device is connected** (daisy chain), else `0` |

If no response within ~½ second, the Macintosh retries the command.

### 5.4 Test (`$36`)

Requests the keyboard self-test.

- Returns **ACK** `$7D` if successful
- Returns **NAK** `$77` if failed

---

## 6. Keyboard responses (keyboard → Mac)

### 6.1 Transition (key up/down) response format

A key transition is encoded in a single byte:

| Bit | Meaning                               |
| --- | ------------------------------------- |
| 7   | `1` = **key-up**, `0` = **key-down**  |
| 6–1 | Key identifier (“raw” key code field) |
| 0   | Always `1`                            |

### 6.2 Special response bytes

| Name     | Value | Meaning                                                          |
| -------- | ----- | ---------------------------------------------------------------- |
| **Null** | `$7B` | No key transition (also proves the keyboard is alive/responding) |
| **ACK**  | `$7D` | Test passed                                                      |
| **NAK**  | `$77` | Test failed                                                      |

### 6.3 Raw transition byte → OS “virtual keycode”

Classic Mac keyboard software typically converts the transition byte to a
“virtual” keycode by removing bit 7 (up/down) and bit 0, then shifting:

```
virtual_keycode = (raw_response & 0x7E) >> 1
```

**Examples:**

| Raw response | Meaning            | Virtual keycode |
| ------------ | ------------------ | --------------- |
| `$33`        | key-down           | `$19`           |
| `$B3`        | key-up of same key | `$19`           |

> Note: The "virtual" codes derived from Mac Plus raw codes happen to match the
> **ADB virtual key codes** defined in *Inside Macintosh* Vol V for most keys.
> This emulator uses ADB virtual codes as the standard API.

### 6.4 Key code table

Each physical key has a fixed raw code for key-down; key-up is the same code
with bit 7 set. The **ADB Virtual** column shows the standard ADB key code used
as the emulator API. The following sections provide complete tables of raw key
codes for the Macintosh Plus keyboard.

#### 6.4.1 Main keyboard keys

| Key      | ADB Virtual | Raw Down | Raw Up | Character(s)        |
| -------- | ----------- | -------- | ------ | ------------------- |
| A        | `$00`       | `$01`    | `$81`  | a / A               |
| S        | `$01`       | `$03`    | `$83`  | s / S               |
| D        | `$02`       | `$05`    | `$85`  | d / D               |
| F        | `$03`       | `$07`    | `$87`  | f / F               |
| H        | `$04`       | `$09`    | `$89`  | h / H               |
| G        | `$05`       | `$0B`    | `$8B`  | g / G               |
| Z        | `$06`       | `$0D`    | `$8D`  | z / Z               |
| X        | `$07`       | `$0F`    | `$8F`  | x / X               |
| C        | `$08`       | `$11`    | `$91`  | c / C               |
| V        | `$09`       | `$13`    | `$93`  | v / V               |
| § / ±    | `$0A`       | `$15`    | `$95`  | § (non-US ISO)      |
| B        | `$0B`       | `$17`    | `$97`  | b / B               |
| Q        | `$0C`       | `$19`    | `$99`  | q / Q               |
| W        | `$0D`       | `$1B`    | `$9B`  | w / W               |
| E        | `$0E`       | `$1D`    | `$9D`  | e / E               |
| R        | `$0F`       | `$1F`    | `$9F`  | r / R               |
| Y        | `$10`       | `$21`    | `$A1`  | y / Y               |
| T        | `$11`       | `$23`    | `$A3`  | t / T               |
| 1        | `$12`       | `$25`    | `$A5`  | 1 / !               |
| 2        | `$13`       | `$27`    | `$A7`  | 2 / @               |
| 3        | `$14`       | `$29`    | `$A9`  | 3 / #               |
| 4        | `$15`       | `$2B`    | `$AB`  | 4 / $               |
| 6        | `$16`       | `$2D`    | `$AD`  | 6 / ^               |
| 5        | `$17`       | `$2F`    | `$AF`  | 5 / %               |
| =        | `$18`       | `$31`    | `$B1`  | = / +               |
| 9        | `$19`       | `$33`    | `$B3`  | 9 / (               |
| 7        | `$1A`       | `$35`    | `$B5`  | 7 / &               |
| -        | `$1B`       | `$37`    | `$B7`  | - / \_              |
| 8        | `$1C`       | `$39`    | `$B9`  | 8 / \*              |
| 0        | `$1D`       | `$3B`    | `$BB`  | 0 / )               |
| ]        | `$1E`       | `$3D`    | `$BD`  | ] / }               |
| O        | `$1F`       | `$3F`    | `$BF`  | o / O               |
| U        | `$20`       | `$41`    | `$C1`  | u / U               |
| [        | `$21`       | `$43`    | `$C3`  | [ / {               |
| I        | `$22`       | `$45`    | `$C5`  | i / I               |
| P        | `$23`       | `$47`    | `$C7`  | p / P               |
| Return   | `$24`       | `$49`    | `$C9`  | `$0D` (CR)          |
| L        | `$25`       | `$4B`    | `$CB`  | l / L               |
| J        | `$26`       | `$4D`    | `$CD`  | j / J               |
| '        | `$27`       | `$4F`    | `$CF`  | ' / "               |
| K        | `$28`       | `$51`    | `$D1`  | k / K               |
| ;        | `$29`       | `$53`    | `$D3`  | ; / :               |
| \        | `$2A`       | `$55`    | `$D5`  | \ / \|              |
| ,        | `$2B`       | `$57`    | `$D7`  | , / <               |
| /        | `$2C`       | `$59`    | `$D9`  | / / ?               |
| N        | `$2D`       | `$5B`    | `$DB`  | n / N               |
| M        | `$2E`       | `$5D`    | `$DD`  | m / M               |
| .        | `$2F`       | `$5F`    | `$DF`  | . / >               |
| Tab      | `$30`       | `$61`    | `$E1`  | `$09`               |
| Space    | `$31`       | `$63`    | `$E3`  | `$20`               |
| \`       | `$32`       | `$65`    | `$E5`  | \` / ~              |
| Delete   | `$33`       | `$67`    | `$E7`  | `$08` (Backspace)   |
| (undef)  | `$34`       | `$69`    | `$E9`  | —                   |
| Escape   | `$35`       | `$6B`    | `$EB`  | `$1B`               |
| Control  | `$36`       | `$6D`    | `$ED`  | Modifier            |
| Command  | `$37`       | `$6F`    | `$EF`  | Modifier            |
| Shift    | `$38`       | `$71`    | `$F1`  | Modifier            |
| CapsLock | `$39`       | `$73`    | `$F3`  | Modifier            |
| Option   | `$3A`       | `$75`    | `$F5`  | Modifier            |

**Arrow keys** use the keypad protocol: each transition is preceded by `$79`
(keypad prefix), then the raw code which is shared with a letter key:

| Key   | ADB Virtual | Raw Down         | Raw Up           | Shared With |
| ----- | ----------- | ---------------- | ---------------- | ----------- |
| Left  | `$7B`       | `$79` then `$0D` | `$79` then `$8D` | Z           |
| Right | `$7C`       | `$79` then `$05` | `$79` then `$85` | D           |
| Down  | `$7D`       | `$79` then `$11` | `$79` then `$91` | C           |
| Up    | `$7E`       | `$79` then `$1B` | `$79` then `$9B` | W           |

#### 6.4.2 Numeric keypad

**Numeric keypad keys** use the keypad protocol: each transition is preceded by
`$79` (keypad prefix), then the raw code which is shared with a main keyboard key:

| Key          | ADB Virtual | Raw Down         | Raw Up           | Shared With |
| ------------ | ----------- | ---------------- | ---------------- | ----------- |
| Keypad .     | `$41`       | `$79` then `$03` | `$79` then `$83` | S           |
| Keypad \*    | `$43`       | `$79` then `$05` | `$79` then `$85` | D           |
| Keypad +     | `$45`       | `$79` then `$0D` | `$79` then `$8D` | Z           |
| Keypad Clear | `$47`       | `$0F`            | `$8F`            | X (unique)  |
| Keypad /     | `$4B`       | `$79` then `$1B` | `$79` then `$9B` | W           |
| Keypad Enter | `$4C`       | `$79` then `$19` | `$79` then `$99` | Q           |
| Keypad -     | `$4E`       | `$79` then `$1D` | `$79` then `$9D` | E           |
| Keypad =     | `$51`       | `$79` then `$11` | `$79` then `$91` | C           |
| Keypad 0     | `$52`       | `$79` then `$25` | `$79` then `$A5` | 1           |
| Keypad 1     | `$53`       | `$79` then `$27` | `$79` then `$A7` | 2           |
| Keypad 2     | `$54`       | `$79` then `$29` | `$79` then `$A9` | 3           |
| Keypad 3     | `$55`       | `$79` then `$2B` | `$79` then `$AB` | 4           |
| Keypad 4     | `$56`       | `$79` then `$2D` | `$79` then `$AD` | 6           |
| Keypad 5     | `$57`       | `$79` then `$2F` | `$79` then `$AF` | 5           |
| Keypad 6     | `$58`       | `$79` then `$31` | `$79` then `$B1` | =           |
| Keypad 7     | `$59`       | `$79` then `$33` | `$79` then `$B3` | 9           |
| Keypad 8     | `$5B`       | `$79` then `$37` | `$79` then `$B7` | -           |
| Keypad 9     | `$5C`       | `$79` then `$39` | `$79` then `$B9` | 8           |

#### 6.4.3 Quick reference for commonly used keys

| Key       | ADB Virtual | Raw Down | Raw Up |
| --------- | ----------- | -------- | ------ |
| Space     | `$31`       | `$63`    | `$E3`  |
| Return    | `$24`       | `$49`    | `$C9`  |
| Delete    | `$33`       | `$67`    | `$E7`  |
| Tab       | `$30`       | `$61`    | `$E1`  |
| Escape    | `$35`       | `$6B`    | `$EB`  |
| Command   | `$37`       | `$6F`    | `$EF`  |
| Shift     | `$38`       | `$71`    | `$F1`  |
| Option    | `$3A`       | `$75`    | `$F5`  |
| Control   | `$36`       | `$6D`    | `$ED`  |
| Caps Lock | `$39`       | `$73`    | `$F3`  |
| Left      | `$7B`       | `$79`+`$0D` | `$79`+`$8D` |
| Right     | `$7C`       | `$79`+`$05` | `$79`+`$85` |
| Down      | `$7D`       | `$79`+`$11` | `$79`+`$91` |
| Up        | `$7E`       | `$79`+`$1B` | `$79`+`$9B` |

#### 6.4.4 Implementation notes

1. **Bit 0 validation**: Software can validate raw codes by checking that bit 0
   is always `1`. If bit 0 is `0`, the transmission may be corrupt.

2. **Key-up detection**: Bit 7 indicates the transition type. Software must
   track both key-down and key-up to maintain the KeyMap bitmap accurately.

3. **Keypad prefix protocol**: Arrow keys and numeric keypad keys are
   distinguished from main keyboard keys by sending the `$79` keypad prefix
   before the raw code. The raw codes themselves are shared with letter/number
   keys on the main keyboard.

4. **Number key ordering**: Note that the physical layout places `6` before `5`
   in the ADB virtual keycode sequence (`$16` vs `$17`), though they are adjacent
   on the keyboard.

---

## 7. Compatibility behaviors: keypad and arrow-key special cases

The Macintosh Plus keyboard integrates the numeric keypad and arrow keys, but it
retains compatibility behaviors inherited from earlier Macintosh models
(128K/512K/512Ke) where a **separate external keypad** could exist.

### 7.1 “Separate keypad protocol” behaviors (legacy compatibility)

Some key events may be represented using sequences that resemble “keypad device”
responses:

- **Arrow keys** (sometimes described as “lowercase keypad keys” in older docs):
  - Respond with `$79` (keypad response marker) plus a key code.
- **Keypad symbols `+`, `*`, `/`** (sometimes described as “uppercase keypad”):
  - Respond with `$71` (Shift key-down), then `$79` (keypad response marker),
    then the code.

These compatibility sequences matter if you are emulating the earlier
multi-device chain behavior or software that assumes it.

### 7.2 Driver adjustments for keypad/arrows

Some classic software paths treat keypad and arrow transitions specially:

- After converting `(raw & 0x7E) >> 1`, keypad/arrow keys may receive an
  additional **`+ $40`** offset to reach a distinct range.

(Exact behavior depends on the ROM/OS version and the KMAP resource used.)

### 7.3 External keypad (pre-Plus) as intermediary

On pre-Plus systems using a separate keypad:

- The keyboard could plug into the keypad, and the keypad into the Mac.
- The keypad forwards commands/responses depending on whether a transition
  occurred on the keypad or the keyboard.
- The same Inquiry/Instant polling model applies.

For a Macintosh Plus emulator, you can typically model this only if you
explicitly want to emulate the full daisy-chain topology.

---

## 8. Macintosh-side software model (classic Mac OS expectations)

This section summarizes how classic Mac OS (and ROM code) generally consumes the
protocol.

### 8.1 Low-memory globals

Classic Mac OS maintains keyboard state and configuration in low-memory global
variables. The most important ones for keyboard operation are:

**Keyboard Manager Variables:**

| Global      | Address | Size    | Description                       |
| ----------- | ------- | ------- | --------------------------------- |
| `VIA`       | `$1D4`  | pointer | VIA1 base address pointer         |
| `KbdVars`   | `$216`  | 4 bytes | Keyboard manager variables        |
| `HiKeyLast` | `$216`  | word    | Same as KbdVars (ASCII high byte) |
| `KbdLast`   | `$218`  | word    | Same as KbdVars+2 (raw keycode)   |
| `JKybdTask` | `$21A`  | pointer | Keyboard VBL task hook            |
| `KbdType`   | `$21E`  | byte    | Keyboard model number             |

**Key State Tracking:**

| Global         | Address | Size | Description                           |
| -------------- | ------- | ---- | ------------------------------------- |
| `KeyLast`      | `$184`  | word | ASCII for last valid keycode          |
| `KeyTime`      | `$186`  | long | Tick count when KeyLast was received  |
| `KeyRepTime`   | `$18A`  | long | Tick count when key was last repeated |
| `KeyThresh`    | `$18E`  | word | Auto-key initial delay threshold      |
| `KeyRepThresh` | `$190`  | word | Auto-key repeat rate threshold        |

**Key Bitmap:**

| Global      | Address | Size     | Description                         |
| ----------- | ------- | -------- | ----------------------------------- |
| `KeyMap`    | `$174`  | 16 bytes | Bitmap of keyboard state (128 keys) |
| `KeypadMap` | `$17C`  | long     | Bitmap for numeric keypad (18 bits) |

The `KeyMap` is a 128-bit bitmap where each bit represents a key's current state
(1 = pressed, 0 = released).

**Key Translation:**

| Global      | Address | Size    | Description                         |
| ----------- | ------- | ------- | ----------------------------------- |
| `Key1Trans` | `$29E`  | pointer | Keyboard translator procedure       |
| `Key2Trans` | `$2A2`  | pointer | Numeric keypad translator procedure |

### 8.2 VIA1 register map

For reference, the complete VIA1 register map (base address at `[VIA]` =
`$1D4`):

| Offset  | Register | Keyboard Function                  |
| ------- | -------- | ---------------------------------- |
| `$0000` | vBufB    | Port B (mouse/misc state)          |
| `$0200` | vDirB    | Data direction register B          |
| `$0400` | vDirA    | Data direction register A          |
| `$0600` | vT1C     | Timer 1 counter (low)              |
| `$0800` | vT1CH    | Timer 1 counter (high)             |
| `$0A00` | vT1L     | Timer 1 latch (low)                |
| `$0C00` | vT1LH    | Timer 1 latch (high)               |
| `$0E00` | vT2C     | Timer 2 counter (low)              |
| `$1000` | vT2CH    | Timer 2 counter (high)             |
| `$1200` | —        | Reserved                           |
| `$1400` | vSR      | **Shift Register (keyboard data)** |
| `$1600` | vACR     | **Auxiliary Control (shift mode)** |
| `$1800` | vPCR     | **Peripheral Control**             |
| `$1A00` | vIFR     | **Interrupt Flags**                |
| `$1C00` | vIER     | **Interrupt Enable**               |
| `$1E00` | vBufA    | Port A (no handshake)              |

### 8.3 Polling schedule and timeouts

Typical behavior:

- Send **Inquiry (`$10`)** roughly every **¼ second** in steady-state.
- If no reply is received within about **½ second**, assume the keyboard is
  missing or wedged and reinitialize by sending **Model Number (`$16`)** again.

### 8.4 VBL integration

Classic systems often invoke a keyboard task from the **Vertical Retrace (VBL)**
manager. A common pattern is:

- cursor task every VBL
- keyboard (and mouse button) tasks every **other** VBL

The keyboard task is called via the `JKybdTask` hook (`$21A`) during VBL
processing. The task:

1. Sends Inquiry command to keyboard
2. Reads response from VIA shift register
3. Processes key transition or null response
4. Updates key state and posts events as needed

### 8.5 Key state bitmap (`KeyMap`) and modifiers

The system maintains a **128-bit key state bitmap** (`KeyMap`, 16 bytes) in low
memory at address `$174`. Each bit represents whether a key is currently down.

Modifier keys are represented by specific bit positions within the bitmap.
Modifier flags exist in bits `$37` to `$3E` of the key bitmap:

```
Byte  |           6           |           7           |
Bit   |37 36 35 34 33 32 31 30|3F 3E 3D 3C 3B 3A 39 38|
      |^^                     |   ^^ ^^ ^^ ^^ ^^ ^^ ^^|
```

The modifier word is extracted from `KeyBits+6` and the OS rotates these bits to
form a modifier word (e.g., to place the Command key where the toolbox expects
it):

```assembly
MOVE.W  KeyBits+6(A2), D0   ; Get modifier word
ROL.W   #1, D0              ; Rotate in command key
```

### 8.6 Key translation (KMAP/KCHR and `_KeyTrans`)

Classic Mac OS splits "what key was pressed" from "what character was produced":

- **KMAP** resources provide a raw-to-virtual mapping and exception handling for
  special keys.
- **KCHR** resources provide translation from virtual keycodes + modifiers to
  produced characters via the `_KeyTrans` trap, including dead-key handling.

**Keyboard Driver Private Data Area:**

The keyboard driver maintains a private data structure with these fields:

| Field      | Size     | Description                               |
| ---------- | -------- | ----------------------------------------- |
| `KMAPPtr`  | long     | Pointer to KMAP resource                  |
| `KeyBits`  | 16 bytes | Local key bitmap (128 bits)               |
| `KCHRPtr`  | long     | Pointer to KCHR resource                  |
| `DeadKey`  | long     | Dead key state for \_KeyTrans             |
| `KNumBufs` | byte     | Number of available buffers               |
| `KNoADBOp` | byte     | Flag to suppress ADB operations (ADB-era) |

The KMAP resource structure includes:

- `KMstart` - Beginning of keycode mapping table
- `KMnumEx` - Number of exception entries

An accurate emulator should:

- deliver correct raw transition bytes to the OS driver, and/or
- implement the OS’s keymap/translation mechanisms if you’re emulating the
  ROM/OS at that level.

### 8.7 Event generation (`_PostEvent` message format)

Keyboard events are posted as `keyDown` (event 3), `keyUp` (event 4), or
`autoKey` (event 5) events with an event message that combines:

- translated character (high/low bytes),
- device/address info (historically ADB-related, but reused),
- and the raw keycode byte.

The event message format is a 32-bit value packed as `HFRL`:

| Byte      | Bits  | Content                             |
| --------- | ----- | ----------------------------------- |
| High byte | 24-31 | **H** = ASCII character (high byte) |
| Byte 2    | 16-23 | **F** = ADB address / device info   |
| Byte 1    | 8-15  | **R** = Raw keycode                 |
| Low byte  | 0-7   | **L** = ASCII character (low byte)  |

---

## 9. Auto-key repeat

Auto-repeat is typically handled by the keyboard task (often VBL-driven):

1. On key-down, record `KeyTime` and initialize `KeyRepTime`.
2. Wait until elapsed time exceeds `KeyThresh` (initial delay).
3. Generate `autoKey` events at intervals defined by `KeyRepThresh`.

Repeat/delay values are commonly stored in Parameter RAM (PRAM) as small encoded
fields (often in units of 4/60ths of a second), though the precise encoding
varies by ROM/OS generation.

---

## 10. Emulation guidance and common pitfalls

### 10.1 Model the bidirectional DATA line correctly

At minimum your emulation should support:

- Mac driving DATA during command byte shift-out
- keyboard driving DATA during reply shift-in
- correct idle/release behavior (DATA high when not driven)

Incorrect ownership of the DATA line is a frequent source of subtle failures
(missed bytes, stuck “key down”, etc.).

### 10.2 Respect the two different bit rates

Many emulators “speed up” or collapse timing; for the Plus keyboard interface,
software can be sensitive to:

- ~330 µs per bit when keyboard → Mac
- ~400 µs per bit when Mac → keyboard

Even if you do not emulate microsecond-perfect waveforms, keep ordering
constraints (setup/hold relative to clock edges) and do not reorder the shift-in
vs shift-out phases.

### 10.3 VIA SR completion timing: do not raise SR-done immediately on write

On real hardware, when the Mac writes a command byte to the VIA SR in shift-out
mode:

- the SR shifts the 8 bits out under VIA/VIA-clock control, and only **after the
  8 shift clocks** does the VIA set the SR interrupt flag (`IFR.ifSR`), which
  triggers the ISR that switches to shift-in mode.

If an emulator incorrectly asserts SR-done **immediately** on SR write, the ISR
runs too early and may switch to shift-in mode before the keyboard has even
started its response, causing intermittent dropped replies and timeouts.

**Practical emulation rule:** schedule the SR-done flag/interrupt after the SR
has actually completed its 8 shifts for the current SR mode, rather than at the
moment the program writes `vSR`.

---

## 11. Comparison: Mac Plus vs. ADB keyboards

The Mac Plus keyboard protocol was replaced by ADB (Apple Desktop Bus) starting
with the Macintosh SE (1987). Understanding the differences is useful for
context:

| Feature            | Mac Plus (Non-ADB)          | ADB (SE and later)              |
| ------------------ | --------------------------- | ------------------------------- |
| **Bus type**       | Dedicated serial            | Multi-device bus                |
| **Clock source**   | Keyboard-driven synchronous | Asynchronous protocol           |
| **Addressing**     | None (single device)        | Device addresses (0-15)         |
| **Communication**  | VIA shift register          | ADB controller (or IOP)         |
| **Commands**       | 4 simple commands           | Full command set with registers |
| **Interrupt**      | VIA1 SR interrupt           | VIA1 SR or ADB IOP interrupt    |
| **Initialization** | Model Number command        | ADB bus reset and enumeration   |
| **Hot-swap**       | Not supported               | Supported                       |

ADB provided multiple device support, hot-swapping capability, and a unified
interface for keyboards, mice, and other input devices. However, the Mac Plus
protocol remains important for vintage Mac restoration, hardware emulation, and
understanding Apple's input device evolution.

---

## 12. Summary checklist (minimum behavior for a robust emulator)

1. Implement the **RJ-11 keyboard port** signals logically (DATA + CLOCK +
   power).
2. Implement the **master-initiated transaction**: Mac pulls DATA low, keyboard
   clocks, Mac sends command, then keyboard responds.
3. Implement **MSB-first 8-bit transfers** and the documented timings (or a
   faithful logical equivalent).
4. Support all four commands: `$10`, `$14`, `$16`, `$36`, including timeouts and
   retries.
5. Generate correct keyboard responses: transitions, `$7B`, `$7D`, `$77`.
6. Convert/route transitions to the OS driver correctly (and apply legacy keypad
   behaviors if you emulate them).
7. Emulate VIA SR behavior closely enough that SR-done interrupts occur at the
   right time and direction switching is not premature.
