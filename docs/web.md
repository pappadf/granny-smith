# Web Frontend Reference

The Granny Smith web frontend lives in `web/index.html`. The page and its inline module script act as the single entry point for initializing the emulator, wiring terminal I/O, and handling user interaction. This reference documents both the user-facing capabilities and the architectural details you need when modifying the UI or embedding it elsewhere.

## Capabilities and Requirements

### Layout and Major Elements
- **Canvas (`#screen`)**: Displays the 512×342 Macintosh Plus framebuffer. The containing `.screen-wrapper` resizes when zoom changes (default 200%, clamped 100–300%).
- **ROM overlay (`#rom-required-overlay`)**: Blocks the screen until `/persist/boot/rom` is present. Dragging a valid ROM or providing one via URL hides the overlay after `load-rom` succeeds.
- **Drop hint (`#drop-hint`)**: Appears when files are dragged into the viewport. Automatically dismissed on drop, dragleave, or ESC.
- **Terminal panel (`#terminal-panel`)**: Collapsible xterm.js console wired to the emulator shell. Toggled via the header row or the backtick (`) key.

### Toolbar Controls
- **Run button (`#btn-run`)**: Play/pause toggle. When idle it issues `run`. When running it sends Ctrl-C via `shell_interrupt`. First click also resumes the WebAudio context so the boot chime can play on browsers with autoplay restrictions.
- **Zoom out / level / zoom in (`#zoom-out`, `#zoom-level`, `#zoom-in`)**: Adjust the canvas scale in 10% increments, persisted to `localStorage` as `zoomPct`.
- **Download State (`#btn-download`)**: Saves a temporary checkpoint (`/tmp/saved-state-YYYYMMDD-HHMMSS.bin`) through `save-state` followed by `download`. Automatically pauses and resumes the VM around the export.
- **Share (`#btn-share`)**: Copies `location.href` to the clipboard to preserve any URL parameters.
- **Settings (`#btn-settings`)**: Opens a modal placeholder. Currently no toggles are implemented.

### Keyboard Shortcuts in Terminal
- Standard line editing: arrows, Home/End, Delete, history navigation, Ctrl+L clear, Ctrl+C interrupt. Input is buffered client-side and flushed through `handle_command` on Enter.

### Drag-and-Drop and File Picker
- **ROM files (exactly 128 KiB)**: Written to `/persist/boot/rom`. Emulator auto-runs once loaded. Overlay hides.
- **Floppy images (>128 KiB and <2 MiB)**: Stored under `/fd/<basename>` in in-memory FS, then inserted with `insert-fd` (with run/resume sequencing if needed).
- **Hard-disk images (>5 MiB)**: Stored in `/persist/boot/hdN` (first free slot 0–7). Because SCSI disks must attach before the first `run`, the page reloads after import when a ROM has already been loaded. Otherwise they attach automatically during the initial boot.
- **Checkpoint files**: Detected via `GSCHKPT2` magic. Always copied into `/tmp/<timestamp>-<name>` and loaded using `load-state`, pausing/resuming the VM around the operation.
- **ZIP archives**: Decompressed with JSZip when dropped or fetched via URL. If the contents match checkpoint/media heuristics they follow the same flows; otherwise they are stored in `/tmp`.
- **Unknown or multi-file drops**: Written into `/tmp/` preserving relative paths (directories supported via `webkitGetAsEntry`). A modal dialog and status line notify the user of the destination.
- **File picker (`#file-picker`)**: Hidden `<input type="file" webkitdirectory>` bound to manual uploads (currently triggered by future toolbar options). Selected files mirror into `/persist/<relativePath>` and sync back to IDBFS immediately.

### URL Parameters
- `rom=<url>`: Downloaded into `/persist/boot/rom`, overriding any existing ROM.
- `fdN=<url>` (e.g., `fd0`, `fd1`): Downloaded into `/persist/boot/fdN` and inserted via `insert-fd` after fetch completes.
- `hdN=<url>`: Downloaded into `/persist/boot/hdN`. Auto-attached before the first run.
- `speed=max|realtime|hardware`: Passed to the wasm module as `--speed=`.
- `test=1`: Exposes the Emscripten module on `window.__Module` for Playwright hooks.
- Arbitrary query strings survive the share button copy so pre-configured sessions can be distributed easily.

### Audio Requirements
- Browsers that block WebAudio until a gesture keep `Module.mPlusAudio.ctx` suspended. The frontend listens to pointer, key, click, and touch events to call `ctx.resume()` once; status text warns when SharedArrayBuffer is unavailable (missing COOP/COEP headers).

### Persistence Guarantees
- `/persist` is mounted as IDBFS and survives reloads; `/fd` and `/tmp` are in-memory per session. The page syncs from IndexedDB on load (`FS.syncfs(true)`) and back to disk on `pagehide` or explicit `persistSync()` calls.

## Implementation Details

### Module Bootstrapping
- `main.mjs` (generated by Emscripten) is dynamically imported with a cache-busting query parameter. `createModule` is invoked with:
  - `canvas`: DOM canvas element
  - `arguments`: includes `--model=plus` plus optional `--speed` from URL
  - `locateFile`: appends `?v=<timestamp>` to `.wasm` fetches
  - `print` / `printErr`: funnel to `runtimeWrite`, which interleaves shell output with the prompt.
- After instantiation the script pulls function pointers via `Module.cwrap` (`shell_emit_prompt`, `is_running`) and asynchronous command entry points via `Module.ccall` (`shell_init`, `handle_command`, `shell_interrupt`).
- `Module.onRunStateChange` is exposed so C code can push play/pause state back to the UI without relying solely on polling.

### Terminal Integration (xterm.js)
- xterm.js plus the FitAddon power the interactive console. The terminal is opened inside `#terminal` and resized whenever the panel expands or the viewport changes.
- Input handling is fully client-side: the script maintains `{buffer, cursor, history}`. Editing keystrokes update the buffer and re-render the prompt using ANSI cursor movements. On Enter, the buffer is enqueued through `queueCommand` so sequential commands remain ordered even when `handle_command` is async.
- Terminal output from the wasm runtime uses `runtimeWrite` to temporarily clear and restore the editing line, mirroring a traditional REPL experience.

### Command Pipeline and Run State
- `commandChain` serializes all emulator shell calls (e.g., `queueCommand`, `downloadStateSnapshot`). Failed commands do not break the chain; errors are logged and swallowed to keep later commands running.
- `setRunState` swaps the run button icon, toggles the prompt, and tracks whether a resume is needed after media operations. `waitForRunState` polls the UI boolean, while `currentRunState` queries the wasm `is_running` symbol when available.

### Filesystem and Persistence
- The script pulls `Module.FS` and mounts `FS.filesystems.IDBFS` at `/persist`. Helper utilities:
  - `ensureDirs(path)` and `writeBinary(path, data)` mirror POSIX mkdir/write semantics.
  - Convenience accessors (`romPath`, `floppySlotPath`, `hdSlotPath`) and `fileExists` abstract repeated FS checks.
  - `persistSync()` wraps `FS.syncfs(false)` and is awaited whenever persistent media changes.
- Volatile areas:
  - `/fd`: Ram-backed drop area for floppies (cleared on reload).
  - `/tmp`: Scratch space for multi-file uploads, checkpoints, and exported state.
- Persistent image store (`/persist/images/`):
  - When a disk image is mounted from a volatile location (`/tmp/` or `/fd/`), the `media-persist.js` module automatically copies it to `/persist/images/<hash>.img` before the C core receives the mount command.
  - Images are content-addressed: a simple hash (FNV-1a over first 64 KB + file size) produces an 8-char hex filename. Identical images are never duplicated.
  - The storage engine's `.blocks/` directory is created adjacent to the persistent copy, so it also survives reloads.
  - This ensures quick (background) checkpoints — which reference backing files by path — can restore after a page reload.

### Drag-and-Drop Flow
1. `processDrop` gathers files via `extractAllDroppedFiles`, which supports directories through `webkitGetAsEntry`.
2. If the drop is a single ROM/floppy/HD (determined by size heuristic) the file is passed to `importRecognizedMedia`. Checkpoint detection runs first.
3. Zip archives load lazily via JSZip (ES module import). The first non-directory entry is inspected and either treated as a checkpoint/media file or written to `/tmp`.
4. Multi-file or unrecognized drops route to `storeInTmp`, preserving relative structure and notifying the user via a modal dialog.
5. When a floppy or HD image is mounted from the drop pipeline, the `insert-fd` / `attach-hd` command passes through the `media-persist.js` preprocessor which copies volatile images to `/persist/images/<hash>.img` before the command reaches the C core.

### URL Media Fetching
- `processUrlMedia` iterates URLSearchParams in three passes (ROM, `fdN`, `hdN`). Each `fetchAndStore(slot, url)` downloads the payload, optionally unzips, writes it into `/persist/boot/<slot>`, and emits status toasts.
- After downloads, floppies are hot-inserted through `insert-fd`, while ROM triggers `loadRomAndMaybeRun`. Hard disks are left attached prior to the first `run` via `autoAttachPersistentHDs`.

### ROM Load + Auto-Run
- `loadRomAndMaybeRun` is the single entry for transitioning from idle to running:
  1. `load-rom /persist/boot/rom`
  2. Hide the overlay
  3. Attach persistent HDs (`attach-hd ...` for each slot found)
  4. Issue `run`
- If no ROM is available after the initial IDBFS sync and URL processing, the overlay stays visible until the user supplies one via drag/drop.

### Integration with MemFS / IDBFS
- Every import path eventually goes through `FS.writeFile`, meaning the emulator sees the media as if it were present on its virtual filesystem. For example:
  - ROM: `/persist/boot/rom`
  - URL-provided floppy: `/persist/boot/fd0` → `insert-fd /persist/boot/fd0`
  - Dropped floppy: `/fd/<name>` → `insert-fd /fd/<name>`
  - Hard disk: `/persist/boot/hd0` → `attach-hd /persist/boot/hd0 0`
  - Checkpoint: `/tmp/<timestamp>-<name>` → `load-state /tmp/...`
- Because `/persist` is backed by IDBFS, ROMs, hard disks, and persisted images all survive reloads. `/fd` and `/tmp` exist only until the tab closes.
- Disk images mounted from volatile paths (`/tmp/`, `/fd/`) are automatically copied to `/persist/images/<hash>.img` by the command preprocessor in `media-persist.js`, ensuring quick checkpoint survival.

### xterm ↔ Emscripten Shell Helpers
- Exported helpers (`window.queueCommand`, `window.runCommand`, `window.setStatus`) give other scripts or Playwright tests controlled access to the emulator shell.
- `Module.__gsTestShim._xterm` is populated in test mode so harnesses can read terminal output directly when needed.

### Status Toasts and Dialogs
- `toast()` writes to both `console.log` and the terminal header status span (auto-clears after 2.5s). The upload dialog provides richer feedback when files move into the browser FS.

### Audio Unlock and Feature Detection
- SharedArrayBuffer absence hints to the user that they must serve with COOP/COEP headers (`make run`).
- Event listeners for `pointerdown`, `keydown`, `click`, and `touchstart` try to resume the AudioContext once per session, then remove themselves.

## Extending the Frontend
- When adding new toolbar buttons or modal dialogs, wire their data flow through the existing helpers (`window.queueCommand`, `persistSync`, `storeInTmp`) to keep UX consistent.
- Prefer storing long-lived media under `/persist/boot` to ensure IDBFS sync. Reserve `/tmp` for volatile artifacts. Note that disk images mounted from `/tmp/` are automatically persisted to `/persist/images/` by `media-persist.js`, so even drag-and-drop images survive quick checkpoint restores.
- Any new URL parameter should be handled during `processUrlMedia` so shareable links remain the single source of truth for preconfigured sessions.
- Keep drag-and-drop classification logic centralized in `classifyFile`/`importRecognizedMedia` so heuristics evolve in one place.
